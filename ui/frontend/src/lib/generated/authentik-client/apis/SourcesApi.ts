// tslint:disable
/**
 * authentik
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2023.10.2
 * Contact: hello@goauthentik.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import { BaseAPI, throwIfNullOrUndefined, encodeURI } from '../runtime';
import type { OperationOpts, HttpHeaders, HttpQuery } from '../runtime';
import type {
    FilePathRequest,
    GenericError,
    LDAPDebug,
    LDAPSource,
    LDAPSourceRequest,
    OAuthSource,
    OAuthSourceRequest,
    PaginatedLDAPSourceList,
    PaginatedOAuthSourceList,
    PaginatedPlexSourceConnectionList,
    PaginatedPlexSourceList,
    PaginatedSAMLSourceList,
    PaginatedSourceList,
    PaginatedUserOAuthSourceConnectionList,
    PaginatedUserSAMLSourceConnectionList,
    PaginatedUserSourceConnectionList,
    PatchedLDAPSourceRequest,
    PatchedOAuthSourceRequest,
    PatchedPlexSourceConnectionRequest,
    PatchedPlexSourceRequest,
    PatchedSAMLSourceRequest,
    PatchedUserOAuthSourceConnectionRequest,
    PatchedUserSAMLSourceConnectionRequest,
    PlexSource,
    PlexSourceConnection,
    PlexSourceConnectionRequest,
    PlexSourceRequest,
    PlexTokenRedeemRequest,
    RedirectChallenge,
    SAMLMetadata,
    SAMLSource,
    SAMLSourceRequest,
    Source,
    SourceType,
    Task,
    TypeCreate,
    UsedBy,
    UserOAuthSourceConnection,
    UserOAuthSourceConnectionRequest,
    UserSAMLSourceConnection,
    UserSAMLSourceConnectionRequest,
    UserSetting,
    UserSourceConnection,
    ValidationError,
} from '../models';

export interface SourcesAllDestroyRequest {
    slug: string;
}

export interface SourcesAllListRequest {
    managed?: string;
    name?: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
    search?: string;
    slug?: string;
}

export interface SourcesAllRetrieveRequest {
    slug: string;
}

export interface SourcesAllSetIconCreateRequest {
    slug: string;
    file?: Blob;
    clear?: boolean;
}

export interface SourcesAllSetIconUrlCreateRequest {
    slug: string;
    filePathRequest: FilePathRequest;
}

export interface SourcesAllUsedByListRequest {
    slug: string;
}

export interface SourcesLdapCreateRequest {
    lDAPSourceRequest: LDAPSourceRequest;
}

export interface SourcesLdapDebugRetrieveRequest {
    slug: string;
}

export interface SourcesLdapDestroyRequest {
    slug: string;
}

export interface SourcesLdapListRequest {
    additionalGroupDn?: string;
    additionalUserDn?: string;
    baseDn?: string;
    bindCn?: string;
    clientCertificate?: string;
    enabled?: boolean;
    groupMembershipField?: string;
    groupObjectFilter?: string;
    name?: string;
    objectUniquenessField?: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
    peerCertificate?: string;
    propertyMappings?: Array<string>;
    propertyMappingsGroup?: Array<string>;
    search?: string;
    serverUri?: string;
    slug?: string;
    sni?: boolean;
    startTls?: boolean;
    syncGroups?: boolean;
    syncParentGroup?: string;
    syncUsers?: boolean;
    syncUsersPassword?: boolean;
    userObjectFilter?: string;
}

export interface SourcesLdapPartialUpdateRequest {
    slug: string;
    patchedLDAPSourceRequest?: PatchedLDAPSourceRequest;
}

export interface SourcesLdapRetrieveRequest {
    slug: string;
}

export interface SourcesLdapSyncStatusListRequest {
    slug: string;
}

export interface SourcesLdapUpdateRequest {
    slug: string;
    lDAPSourceRequest: LDAPSourceRequest;
}

export interface SourcesLdapUsedByListRequest {
    slug: string;
}

export interface SourcesOauthCreateRequest {
    oAuthSourceRequest: OAuthSourceRequest;
}

export interface SourcesOauthDestroyRequest {
    slug: string;
}

export interface SourcesOauthListRequest {
    accessTokenUrl?: string;
    additionalScopes?: string;
    authenticationFlow?: string;
    authorizationUrl?: string;
    consumerKey?: string;
    enabled?: boolean;
    enrollmentFlow?: string;
    hasJwks?: boolean;
    name?: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
    policyEngineMode?: SourcesOauthListPolicyEngineModeEnum;
    profileUrl?: string;
    providerType?: string;
    requestTokenUrl?: string;
    search?: string;
    slug?: string;
    userMatchingMode?: SourcesOauthListUserMatchingModeEnum;
}

export interface SourcesOauthPartialUpdateRequest {
    slug: string;
    patchedOAuthSourceRequest?: PatchedOAuthSourceRequest;
}

export interface SourcesOauthRetrieveRequest {
    slug: string;
}

export interface SourcesOauthSourceTypesListRequest {
    name?: string;
}

export interface SourcesOauthUpdateRequest {
    slug: string;
    oAuthSourceRequest: OAuthSourceRequest;
}

export interface SourcesOauthUsedByListRequest {
    slug: string;
}

export interface SourcesPlexCreateRequest {
    plexSourceRequest: PlexSourceRequest;
}

export interface SourcesPlexDestroyRequest {
    slug: string;
}

export interface SourcesPlexListRequest {
    allowFriends?: boolean;
    authenticationFlow?: string;
    clientId?: string;
    enabled?: boolean;
    enrollmentFlow?: string;
    name?: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
    policyEngineMode?: SourcesPlexListPolicyEngineModeEnum;
    search?: string;
    slug?: string;
    userMatchingMode?: SourcesPlexListUserMatchingModeEnum;
}

export interface SourcesPlexPartialUpdateRequest {
    slug: string;
    patchedPlexSourceRequest?: PatchedPlexSourceRequest;
}

export interface SourcesPlexRedeemTokenAuthenticatedCreateRequest {
    plexTokenRedeemRequest: PlexTokenRedeemRequest;
    slug?: string;
}

export interface SourcesPlexRedeemTokenCreateRequest {
    plexTokenRedeemRequest: PlexTokenRedeemRequest;
    slug?: string;
}

export interface SourcesPlexRetrieveRequest {
    slug: string;
}

export interface SourcesPlexUpdateRequest {
    slug: string;
    plexSourceRequest: PlexSourceRequest;
}

export interface SourcesPlexUsedByListRequest {
    slug: string;
}

export interface SourcesSamlCreateRequest {
    sAMLSourceRequest: SAMLSourceRequest;
}

export interface SourcesSamlDestroyRequest {
    slug: string;
}

export interface SourcesSamlListRequest {
    allowIdpInitiated?: boolean;
    authenticationFlow?: string;
    bindingType?: SourcesSamlListBindingTypeEnum;
    digestAlgorithm?: SourcesSamlListDigestAlgorithmEnum;
    enabled?: boolean;
    enrollmentFlow?: string;
    issuer?: string;
    managed?: string;
    name?: string;
    nameIdPolicy?: SourcesSamlListNameIdPolicyEnum;
    ordering?: string;
    page?: number;
    pageSize?: number;
    policyEngineMode?: SourcesSamlListPolicyEngineModeEnum;
    preAuthenticationFlow?: string;
    search?: string;
    signatureAlgorithm?: SourcesSamlListSignatureAlgorithmEnum;
    signingKp?: string;
    sloUrl?: string;
    slug?: string;
    ssoUrl?: string;
    temporaryUserDeleteAfter?: string;
    userMatchingMode?: SourcesSamlListUserMatchingModeEnum;
    verificationKp?: string;
}

export interface SourcesSamlMetadataRetrieveRequest {
    slug: string;
}

export interface SourcesSamlPartialUpdateRequest {
    slug: string;
    patchedSAMLSourceRequest?: PatchedSAMLSourceRequest;
}

export interface SourcesSamlRetrieveRequest {
    slug: string;
}

export interface SourcesSamlUpdateRequest {
    slug: string;
    sAMLSourceRequest: SAMLSourceRequest;
}

export interface SourcesSamlUsedByListRequest {
    slug: string;
}

export interface SourcesUserConnectionsAllDestroyRequest {
    id: number;
}

export interface SourcesUserConnectionsAllListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
    search?: string;
    user?: number;
}

export interface SourcesUserConnectionsAllPartialUpdateRequest {
    id: number;
}

export interface SourcesUserConnectionsAllRetrieveRequest {
    id: number;
}

export interface SourcesUserConnectionsAllUpdateRequest {
    id: number;
}

export interface SourcesUserConnectionsAllUsedByListRequest {
    id: number;
}

export interface SourcesUserConnectionsOauthCreateRequest {
    userOAuthSourceConnectionRequest: UserOAuthSourceConnectionRequest;
}

export interface SourcesUserConnectionsOauthDestroyRequest {
    id: number;
}

export interface SourcesUserConnectionsOauthListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
    search?: string;
    sourceSlug?: string;
}

export interface SourcesUserConnectionsOauthPartialUpdateRequest {
    id: number;
    patchedUserOAuthSourceConnectionRequest?: PatchedUserOAuthSourceConnectionRequest;
}

export interface SourcesUserConnectionsOauthRetrieveRequest {
    id: number;
}

export interface SourcesUserConnectionsOauthUpdateRequest {
    id: number;
    userOAuthSourceConnectionRequest: UserOAuthSourceConnectionRequest;
}

export interface SourcesUserConnectionsOauthUsedByListRequest {
    id: number;
}

export interface SourcesUserConnectionsPlexCreateRequest {
    plexSourceConnectionRequest: PlexSourceConnectionRequest;
}

export interface SourcesUserConnectionsPlexDestroyRequest {
    id: number;
}

export interface SourcesUserConnectionsPlexListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
    search?: string;
    sourceSlug?: string;
}

export interface SourcesUserConnectionsPlexPartialUpdateRequest {
    id: number;
    patchedPlexSourceConnectionRequest?: PatchedPlexSourceConnectionRequest;
}

export interface SourcesUserConnectionsPlexRetrieveRequest {
    id: number;
}

export interface SourcesUserConnectionsPlexUpdateRequest {
    id: number;
    plexSourceConnectionRequest: PlexSourceConnectionRequest;
}

export interface SourcesUserConnectionsPlexUsedByListRequest {
    id: number;
}

export interface SourcesUserConnectionsSamlCreateRequest {
    userSAMLSourceConnectionRequest: UserSAMLSourceConnectionRequest;
}

export interface SourcesUserConnectionsSamlDestroyRequest {
    id: number;
}

export interface SourcesUserConnectionsSamlListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
    search?: string;
    sourceSlug?: string;
}

export interface SourcesUserConnectionsSamlPartialUpdateRequest {
    id: number;
    patchedUserSAMLSourceConnectionRequest?: PatchedUserSAMLSourceConnectionRequest;
}

export interface SourcesUserConnectionsSamlRetrieveRequest {
    id: number;
}

export interface SourcesUserConnectionsSamlUpdateRequest {
    id: number;
    userSAMLSourceConnectionRequest: UserSAMLSourceConnectionRequest;
}

export interface SourcesUserConnectionsSamlUsedByListRequest {
    id: number;
}

/**
 * no description
 */
export class SourcesApi extends BaseAPI {

    /**
     * Source Viewset
     */
    sourcesAllDestroy({ slug }: SourcesAllDestroyRequest): Observable<void>
    sourcesAllDestroy({ slug }: SourcesAllDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    sourcesAllDestroy({ slug }: SourcesAllDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesAllDestroy');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<void>({
            url: '/sources/all/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesAllList({ managed, name, ordering, page, pageSize, search, slug }: SourcesAllListRequest): Observable<PaginatedSourceList>
    sourcesAllList({ managed, name, ordering, page, pageSize, search, slug }: SourcesAllListRequest, opts?: OperationOpts): Observable<AjaxResponse<PaginatedSourceList>>
    sourcesAllList({ managed, name, ordering, page, pageSize, search, slug }: SourcesAllListRequest, opts?: OperationOpts): Observable<PaginatedSourceList | AjaxResponse<PaginatedSourceList>> {

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const query: HttpQuery = {};

        if (managed != null) { query['managed'] = managed; }
        if (name != null) { query['name'] = name; }
        if (ordering != null) { query['ordering'] = ordering; }
        if (page != null) { query['page'] = page; }
        if (pageSize != null) { query['page_size'] = pageSize; }
        if (search != null) { query['search'] = search; }
        if (slug != null) { query['slug'] = slug; }

        return this.request<PaginatedSourceList>({
            url: '/sources/all/',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesAllRetrieve({ slug }: SourcesAllRetrieveRequest): Observable<Source>
    sourcesAllRetrieve({ slug }: SourcesAllRetrieveRequest, opts?: OperationOpts): Observable<AjaxResponse<Source>>
    sourcesAllRetrieve({ slug }: SourcesAllRetrieveRequest, opts?: OperationOpts): Observable<Source | AjaxResponse<Source>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesAllRetrieve');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Source>({
            url: '/sources/all/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Set source icon
     */
    sourcesAllSetIconCreate({ slug, file, clear }: SourcesAllSetIconCreateRequest): Observable<void>
    sourcesAllSetIconCreate({ slug, file, clear }: SourcesAllSetIconCreateRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    sourcesAllSetIconCreate({ slug, file, clear }: SourcesAllSetIconCreateRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesAllSetIconCreate');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const formData = new FormData();
        if (file !== undefined) { formData.append('file', file as any); }
        if (clear !== undefined) { formData.append('clear', clear as any); }

        return this.request<void>({
            url: '/sources/all/{slug}/set_icon/'.replace('{slug}', encodeURI(slug)),
            method: 'POST',
            headers,
            body: formData,
        }, opts?.responseOpts);
    };

    /**
     * Set source icon (as URL)
     */
    sourcesAllSetIconUrlCreate({ slug, filePathRequest }: SourcesAllSetIconUrlCreateRequest): Observable<void>
    sourcesAllSetIconUrlCreate({ slug, filePathRequest }: SourcesAllSetIconUrlCreateRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    sourcesAllSetIconUrlCreate({ slug, filePathRequest }: SourcesAllSetIconUrlCreateRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesAllSetIconUrlCreate');
        throwIfNullOrUndefined(filePathRequest, 'filePathRequest', 'sourcesAllSetIconUrlCreate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<void>({
            url: '/sources/all/{slug}/set_icon_url/'.replace('{slug}', encodeURI(slug)),
            method: 'POST',
            headers,
            body: filePathRequest,
        }, opts?.responseOpts);
    };

    /**
     * Get all creatable source types
     */
    sourcesAllTypesList(): Observable<Array<TypeCreate>>
    sourcesAllTypesList(opts?: OperationOpts): Observable<AjaxResponse<Array<TypeCreate>>>
    sourcesAllTypesList(opts?: OperationOpts): Observable<Array<TypeCreate> | AjaxResponse<Array<TypeCreate>>> {
        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Array<TypeCreate>>({
            url: '/sources/all/types/',
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of all objects that use this object
     */
    sourcesAllUsedByList({ slug }: SourcesAllUsedByListRequest): Observable<Array<UsedBy>>
    sourcesAllUsedByList({ slug }: SourcesAllUsedByListRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<UsedBy>>>
    sourcesAllUsedByList({ slug }: SourcesAllUsedByListRequest, opts?: OperationOpts): Observable<Array<UsedBy> | AjaxResponse<Array<UsedBy>>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesAllUsedByList');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Array<UsedBy>>({
            url: '/sources/all/{slug}/used_by/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Get all sources the user can configure
     */
    sourcesAllUserSettingsList(): Observable<Array<UserSetting>>
    sourcesAllUserSettingsList(opts?: OperationOpts): Observable<AjaxResponse<Array<UserSetting>>>
    sourcesAllUserSettingsList(opts?: OperationOpts): Observable<Array<UserSetting> | AjaxResponse<Array<UserSetting>>> {
        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Array<UserSetting>>({
            url: '/sources/all/user_settings/',
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * LDAP Source Viewset
     */
    sourcesLdapCreate({ lDAPSourceRequest }: SourcesLdapCreateRequest): Observable<LDAPSource>
    sourcesLdapCreate({ lDAPSourceRequest }: SourcesLdapCreateRequest, opts?: OperationOpts): Observable<AjaxResponse<LDAPSource>>
    sourcesLdapCreate({ lDAPSourceRequest }: SourcesLdapCreateRequest, opts?: OperationOpts): Observable<LDAPSource | AjaxResponse<LDAPSource>> {
        throwIfNullOrUndefined(lDAPSourceRequest, 'lDAPSourceRequest', 'sourcesLdapCreate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<LDAPSource>({
            url: '/sources/ldap/',
            method: 'POST',
            headers,
            body: lDAPSourceRequest,
        }, opts?.responseOpts);
    };

    /**
     * Get raw LDAP data to debug
     */
    sourcesLdapDebugRetrieve({ slug }: SourcesLdapDebugRetrieveRequest): Observable<LDAPDebug>
    sourcesLdapDebugRetrieve({ slug }: SourcesLdapDebugRetrieveRequest, opts?: OperationOpts): Observable<AjaxResponse<LDAPDebug>>
    sourcesLdapDebugRetrieve({ slug }: SourcesLdapDebugRetrieveRequest, opts?: OperationOpts): Observable<LDAPDebug | AjaxResponse<LDAPDebug>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesLdapDebugRetrieve');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<LDAPDebug>({
            url: '/sources/ldap/{slug}/debug/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * LDAP Source Viewset
     */
    sourcesLdapDestroy({ slug }: SourcesLdapDestroyRequest): Observable<void>
    sourcesLdapDestroy({ slug }: SourcesLdapDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    sourcesLdapDestroy({ slug }: SourcesLdapDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesLdapDestroy');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<void>({
            url: '/sources/ldap/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * LDAP Source Viewset
     */
    sourcesLdapList({ additionalGroupDn, additionalUserDn, baseDn, bindCn, clientCertificate, enabled, groupMembershipField, groupObjectFilter, name, objectUniquenessField, ordering, page, pageSize, peerCertificate, propertyMappings, propertyMappingsGroup, search, serverUri, slug, sni, startTls, syncGroups, syncParentGroup, syncUsers, syncUsersPassword, userObjectFilter }: SourcesLdapListRequest): Observable<PaginatedLDAPSourceList>
    sourcesLdapList({ additionalGroupDn, additionalUserDn, baseDn, bindCn, clientCertificate, enabled, groupMembershipField, groupObjectFilter, name, objectUniquenessField, ordering, page, pageSize, peerCertificate, propertyMappings, propertyMappingsGroup, search, serverUri, slug, sni, startTls, syncGroups, syncParentGroup, syncUsers, syncUsersPassword, userObjectFilter }: SourcesLdapListRequest, opts?: OperationOpts): Observable<AjaxResponse<PaginatedLDAPSourceList>>
    sourcesLdapList({ additionalGroupDn, additionalUserDn, baseDn, bindCn, clientCertificate, enabled, groupMembershipField, groupObjectFilter, name, objectUniquenessField, ordering, page, pageSize, peerCertificate, propertyMappings, propertyMappingsGroup, search, serverUri, slug, sni, startTls, syncGroups, syncParentGroup, syncUsers, syncUsersPassword, userObjectFilter }: SourcesLdapListRequest, opts?: OperationOpts): Observable<PaginatedLDAPSourceList | AjaxResponse<PaginatedLDAPSourceList>> {

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const query: HttpQuery = {};

        if (additionalGroupDn != null) { query['additional_group_dn'] = additionalGroupDn; }
        if (additionalUserDn != null) { query['additional_user_dn'] = additionalUserDn; }
        if (baseDn != null) { query['base_dn'] = baseDn; }
        if (bindCn != null) { query['bind_cn'] = bindCn; }
        if (clientCertificate != null) { query['client_certificate'] = clientCertificate; }
        if (enabled != null) { query['enabled'] = enabled; }
        if (groupMembershipField != null) { query['group_membership_field'] = groupMembershipField; }
        if (groupObjectFilter != null) { query['group_object_filter'] = groupObjectFilter; }
        if (name != null) { query['name'] = name; }
        if (objectUniquenessField != null) { query['object_uniqueness_field'] = objectUniquenessField; }
        if (ordering != null) { query['ordering'] = ordering; }
        if (page != null) { query['page'] = page; }
        if (pageSize != null) { query['page_size'] = pageSize; }
        if (peerCertificate != null) { query['peer_certificate'] = peerCertificate; }
        if (propertyMappings != null) { query['property_mappings'] = propertyMappings; }
        if (propertyMappingsGroup != null) { query['property_mappings_group'] = propertyMappingsGroup; }
        if (search != null) { query['search'] = search; }
        if (serverUri != null) { query['server_uri'] = serverUri; }
        if (slug != null) { query['slug'] = slug; }
        if (sni != null) { query['sni'] = sni; }
        if (startTls != null) { query['start_tls'] = startTls; }
        if (syncGroups != null) { query['sync_groups'] = syncGroups; }
        if (syncParentGroup != null) { query['sync_parent_group'] = syncParentGroup; }
        if (syncUsers != null) { query['sync_users'] = syncUsers; }
        if (syncUsersPassword != null) { query['sync_users_password'] = syncUsersPassword; }
        if (userObjectFilter != null) { query['user_object_filter'] = userObjectFilter; }

        return this.request<PaginatedLDAPSourceList>({
            url: '/sources/ldap/',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * LDAP Source Viewset
     */
    sourcesLdapPartialUpdate({ slug, patchedLDAPSourceRequest }: SourcesLdapPartialUpdateRequest): Observable<LDAPSource>
    sourcesLdapPartialUpdate({ slug, patchedLDAPSourceRequest }: SourcesLdapPartialUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<LDAPSource>>
    sourcesLdapPartialUpdate({ slug, patchedLDAPSourceRequest }: SourcesLdapPartialUpdateRequest, opts?: OperationOpts): Observable<LDAPSource | AjaxResponse<LDAPSource>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesLdapPartialUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<LDAPSource>({
            url: '/sources/ldap/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'PATCH',
            headers,
            body: patchedLDAPSourceRequest,
        }, opts?.responseOpts);
    };

    /**
     * LDAP Source Viewset
     */
    sourcesLdapRetrieve({ slug }: SourcesLdapRetrieveRequest): Observable<LDAPSource>
    sourcesLdapRetrieve({ slug }: SourcesLdapRetrieveRequest, opts?: OperationOpts): Observable<AjaxResponse<LDAPSource>>
    sourcesLdapRetrieve({ slug }: SourcesLdapRetrieveRequest, opts?: OperationOpts): Observable<LDAPSource | AjaxResponse<LDAPSource>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesLdapRetrieve');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<LDAPSource>({
            url: '/sources/ldap/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Get source\'s sync status
     */
    sourcesLdapSyncStatusList({ slug }: SourcesLdapSyncStatusListRequest): Observable<Array<Task>>
    sourcesLdapSyncStatusList({ slug }: SourcesLdapSyncStatusListRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<Task>>>
    sourcesLdapSyncStatusList({ slug }: SourcesLdapSyncStatusListRequest, opts?: OperationOpts): Observable<Array<Task> | AjaxResponse<Array<Task>>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesLdapSyncStatusList');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Array<Task>>({
            url: '/sources/ldap/{slug}/sync_status/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * LDAP Source Viewset
     */
    sourcesLdapUpdate({ slug, lDAPSourceRequest }: SourcesLdapUpdateRequest): Observable<LDAPSource>
    sourcesLdapUpdate({ slug, lDAPSourceRequest }: SourcesLdapUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<LDAPSource>>
    sourcesLdapUpdate({ slug, lDAPSourceRequest }: SourcesLdapUpdateRequest, opts?: OperationOpts): Observable<LDAPSource | AjaxResponse<LDAPSource>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesLdapUpdate');
        throwIfNullOrUndefined(lDAPSourceRequest, 'lDAPSourceRequest', 'sourcesLdapUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<LDAPSource>({
            url: '/sources/ldap/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'PUT',
            headers,
            body: lDAPSourceRequest,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of all objects that use this object
     */
    sourcesLdapUsedByList({ slug }: SourcesLdapUsedByListRequest): Observable<Array<UsedBy>>
    sourcesLdapUsedByList({ slug }: SourcesLdapUsedByListRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<UsedBy>>>
    sourcesLdapUsedByList({ slug }: SourcesLdapUsedByListRequest, opts?: OperationOpts): Observable<Array<UsedBy> | AjaxResponse<Array<UsedBy>>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesLdapUsedByList');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Array<UsedBy>>({
            url: '/sources/ldap/{slug}/used_by/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesOauthCreate({ oAuthSourceRequest }: SourcesOauthCreateRequest): Observable<OAuthSource>
    sourcesOauthCreate({ oAuthSourceRequest }: SourcesOauthCreateRequest, opts?: OperationOpts): Observable<AjaxResponse<OAuthSource>>
    sourcesOauthCreate({ oAuthSourceRequest }: SourcesOauthCreateRequest, opts?: OperationOpts): Observable<OAuthSource | AjaxResponse<OAuthSource>> {
        throwIfNullOrUndefined(oAuthSourceRequest, 'oAuthSourceRequest', 'sourcesOauthCreate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<OAuthSource>({
            url: '/sources/oauth/',
            method: 'POST',
            headers,
            body: oAuthSourceRequest,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesOauthDestroy({ slug }: SourcesOauthDestroyRequest): Observable<void>
    sourcesOauthDestroy({ slug }: SourcesOauthDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    sourcesOauthDestroy({ slug }: SourcesOauthDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesOauthDestroy');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<void>({
            url: '/sources/oauth/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesOauthList({ accessTokenUrl, additionalScopes, authenticationFlow, authorizationUrl, consumerKey, enabled, enrollmentFlow, hasJwks, name, ordering, page, pageSize, policyEngineMode, profileUrl, providerType, requestTokenUrl, search, slug, userMatchingMode }: SourcesOauthListRequest): Observable<PaginatedOAuthSourceList>
    sourcesOauthList({ accessTokenUrl, additionalScopes, authenticationFlow, authorizationUrl, consumerKey, enabled, enrollmentFlow, hasJwks, name, ordering, page, pageSize, policyEngineMode, profileUrl, providerType, requestTokenUrl, search, slug, userMatchingMode }: SourcesOauthListRequest, opts?: OperationOpts): Observable<AjaxResponse<PaginatedOAuthSourceList>>
    sourcesOauthList({ accessTokenUrl, additionalScopes, authenticationFlow, authorizationUrl, consumerKey, enabled, enrollmentFlow, hasJwks, name, ordering, page, pageSize, policyEngineMode, profileUrl, providerType, requestTokenUrl, search, slug, userMatchingMode }: SourcesOauthListRequest, opts?: OperationOpts): Observable<PaginatedOAuthSourceList | AjaxResponse<PaginatedOAuthSourceList>> {

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const query: HttpQuery = {};

        if (accessTokenUrl != null) { query['access_token_url'] = accessTokenUrl; }
        if (additionalScopes != null) { query['additional_scopes'] = additionalScopes; }
        if (authenticationFlow != null) { query['authentication_flow'] = authenticationFlow; }
        if (authorizationUrl != null) { query['authorization_url'] = authorizationUrl; }
        if (consumerKey != null) { query['consumer_key'] = consumerKey; }
        if (enabled != null) { query['enabled'] = enabled; }
        if (enrollmentFlow != null) { query['enrollment_flow'] = enrollmentFlow; }
        if (hasJwks != null) { query['has_jwks'] = hasJwks; }
        if (name != null) { query['name'] = name; }
        if (ordering != null) { query['ordering'] = ordering; }
        if (page != null) { query['page'] = page; }
        if (pageSize != null) { query['page_size'] = pageSize; }
        if (policyEngineMode != null) { query['policy_engine_mode'] = policyEngineMode; }
        if (profileUrl != null) { query['profile_url'] = profileUrl; }
        if (providerType != null) { query['provider_type'] = providerType; }
        if (requestTokenUrl != null) { query['request_token_url'] = requestTokenUrl; }
        if (search != null) { query['search'] = search; }
        if (slug != null) { query['slug'] = slug; }
        if (userMatchingMode != null) { query['user_matching_mode'] = userMatchingMode; }

        return this.request<PaginatedOAuthSourceList>({
            url: '/sources/oauth/',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesOauthPartialUpdate({ slug, patchedOAuthSourceRequest }: SourcesOauthPartialUpdateRequest): Observable<OAuthSource>
    sourcesOauthPartialUpdate({ slug, patchedOAuthSourceRequest }: SourcesOauthPartialUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<OAuthSource>>
    sourcesOauthPartialUpdate({ slug, patchedOAuthSourceRequest }: SourcesOauthPartialUpdateRequest, opts?: OperationOpts): Observable<OAuthSource | AjaxResponse<OAuthSource>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesOauthPartialUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<OAuthSource>({
            url: '/sources/oauth/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'PATCH',
            headers,
            body: patchedOAuthSourceRequest,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesOauthRetrieve({ slug }: SourcesOauthRetrieveRequest): Observable<OAuthSource>
    sourcesOauthRetrieve({ slug }: SourcesOauthRetrieveRequest, opts?: OperationOpts): Observable<AjaxResponse<OAuthSource>>
    sourcesOauthRetrieve({ slug }: SourcesOauthRetrieveRequest, opts?: OperationOpts): Observable<OAuthSource | AjaxResponse<OAuthSource>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesOauthRetrieve');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<OAuthSource>({
            url: '/sources/oauth/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Get all creatable source types. If ?name is set, only returns the type for <name>. If <name> isn\'t found, returns the default type.
     */
    sourcesOauthSourceTypesList({ name }: SourcesOauthSourceTypesListRequest): Observable<Array<SourceType>>
    sourcesOauthSourceTypesList({ name }: SourcesOauthSourceTypesListRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<SourceType>>>
    sourcesOauthSourceTypesList({ name }: SourcesOauthSourceTypesListRequest, opts?: OperationOpts): Observable<Array<SourceType> | AjaxResponse<Array<SourceType>>> {

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const query: HttpQuery = {};

        if (name != null) { query['name'] = name; }

        return this.request<Array<SourceType>>({
            url: '/sources/oauth/source_types/',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesOauthUpdate({ slug, oAuthSourceRequest }: SourcesOauthUpdateRequest): Observable<OAuthSource>
    sourcesOauthUpdate({ slug, oAuthSourceRequest }: SourcesOauthUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<OAuthSource>>
    sourcesOauthUpdate({ slug, oAuthSourceRequest }: SourcesOauthUpdateRequest, opts?: OperationOpts): Observable<OAuthSource | AjaxResponse<OAuthSource>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesOauthUpdate');
        throwIfNullOrUndefined(oAuthSourceRequest, 'oAuthSourceRequest', 'sourcesOauthUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<OAuthSource>({
            url: '/sources/oauth/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'PUT',
            headers,
            body: oAuthSourceRequest,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of all objects that use this object
     */
    sourcesOauthUsedByList({ slug }: SourcesOauthUsedByListRequest): Observable<Array<UsedBy>>
    sourcesOauthUsedByList({ slug }: SourcesOauthUsedByListRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<UsedBy>>>
    sourcesOauthUsedByList({ slug }: SourcesOauthUsedByListRequest, opts?: OperationOpts): Observable<Array<UsedBy> | AjaxResponse<Array<UsedBy>>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesOauthUsedByList');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Array<UsedBy>>({
            url: '/sources/oauth/{slug}/used_by/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Plex source Viewset
     */
    sourcesPlexCreate({ plexSourceRequest }: SourcesPlexCreateRequest): Observable<PlexSource>
    sourcesPlexCreate({ plexSourceRequest }: SourcesPlexCreateRequest, opts?: OperationOpts): Observable<AjaxResponse<PlexSource>>
    sourcesPlexCreate({ plexSourceRequest }: SourcesPlexCreateRequest, opts?: OperationOpts): Observable<PlexSource | AjaxResponse<PlexSource>> {
        throwIfNullOrUndefined(plexSourceRequest, 'plexSourceRequest', 'sourcesPlexCreate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<PlexSource>({
            url: '/sources/plex/',
            method: 'POST',
            headers,
            body: plexSourceRequest,
        }, opts?.responseOpts);
    };

    /**
     * Plex source Viewset
     */
    sourcesPlexDestroy({ slug }: SourcesPlexDestroyRequest): Observable<void>
    sourcesPlexDestroy({ slug }: SourcesPlexDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    sourcesPlexDestroy({ slug }: SourcesPlexDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesPlexDestroy');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<void>({
            url: '/sources/plex/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Plex source Viewset
     */
    sourcesPlexList({ allowFriends, authenticationFlow, clientId, enabled, enrollmentFlow, name, ordering, page, pageSize, policyEngineMode, search, slug, userMatchingMode }: SourcesPlexListRequest): Observable<PaginatedPlexSourceList>
    sourcesPlexList({ allowFriends, authenticationFlow, clientId, enabled, enrollmentFlow, name, ordering, page, pageSize, policyEngineMode, search, slug, userMatchingMode }: SourcesPlexListRequest, opts?: OperationOpts): Observable<AjaxResponse<PaginatedPlexSourceList>>
    sourcesPlexList({ allowFriends, authenticationFlow, clientId, enabled, enrollmentFlow, name, ordering, page, pageSize, policyEngineMode, search, slug, userMatchingMode }: SourcesPlexListRequest, opts?: OperationOpts): Observable<PaginatedPlexSourceList | AjaxResponse<PaginatedPlexSourceList>> {

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const query: HttpQuery = {};

        if (allowFriends != null) { query['allow_friends'] = allowFriends; }
        if (authenticationFlow != null) { query['authentication_flow'] = authenticationFlow; }
        if (clientId != null) { query['client_id'] = clientId; }
        if (enabled != null) { query['enabled'] = enabled; }
        if (enrollmentFlow != null) { query['enrollment_flow'] = enrollmentFlow; }
        if (name != null) { query['name'] = name; }
        if (ordering != null) { query['ordering'] = ordering; }
        if (page != null) { query['page'] = page; }
        if (pageSize != null) { query['page_size'] = pageSize; }
        if (policyEngineMode != null) { query['policy_engine_mode'] = policyEngineMode; }
        if (search != null) { query['search'] = search; }
        if (slug != null) { query['slug'] = slug; }
        if (userMatchingMode != null) { query['user_matching_mode'] = userMatchingMode; }

        return this.request<PaginatedPlexSourceList>({
            url: '/sources/plex/',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Plex source Viewset
     */
    sourcesPlexPartialUpdate({ slug, patchedPlexSourceRequest }: SourcesPlexPartialUpdateRequest): Observable<PlexSource>
    sourcesPlexPartialUpdate({ slug, patchedPlexSourceRequest }: SourcesPlexPartialUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<PlexSource>>
    sourcesPlexPartialUpdate({ slug, patchedPlexSourceRequest }: SourcesPlexPartialUpdateRequest, opts?: OperationOpts): Observable<PlexSource | AjaxResponse<PlexSource>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesPlexPartialUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<PlexSource>({
            url: '/sources/plex/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'PATCH',
            headers,
            body: patchedPlexSourceRequest,
        }, opts?.responseOpts);
    };

    /**
     * Redeem a plex token for an authenticated user, creating a connection
     */
    sourcesPlexRedeemTokenAuthenticatedCreate({ plexTokenRedeemRequest, slug }: SourcesPlexRedeemTokenAuthenticatedCreateRequest): Observable<void>
    sourcesPlexRedeemTokenAuthenticatedCreate({ plexTokenRedeemRequest, slug }: SourcesPlexRedeemTokenAuthenticatedCreateRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    sourcesPlexRedeemTokenAuthenticatedCreate({ plexTokenRedeemRequest, slug }: SourcesPlexRedeemTokenAuthenticatedCreateRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(plexTokenRedeemRequest, 'plexTokenRedeemRequest', 'sourcesPlexRedeemTokenAuthenticatedCreate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const query: HttpQuery = {};

        if (slug != null) { query['slug'] = slug; }

        return this.request<void>({
            url: '/sources/plex/redeem_token_authenticated/',
            method: 'POST',
            headers,
            query,
            body: plexTokenRedeemRequest,
        }, opts?.responseOpts);
    };

    /**
     * Redeem a plex token, check it\'s access to resources against what\'s allowed for the source, and redirect to an authentication/enrollment flow.
     */
    sourcesPlexRedeemTokenCreate({ plexTokenRedeemRequest, slug }: SourcesPlexRedeemTokenCreateRequest): Observable<RedirectChallenge>
    sourcesPlexRedeemTokenCreate({ plexTokenRedeemRequest, slug }: SourcesPlexRedeemTokenCreateRequest, opts?: OperationOpts): Observable<AjaxResponse<RedirectChallenge>>
    sourcesPlexRedeemTokenCreate({ plexTokenRedeemRequest, slug }: SourcesPlexRedeemTokenCreateRequest, opts?: OperationOpts): Observable<RedirectChallenge | AjaxResponse<RedirectChallenge>> {
        throwIfNullOrUndefined(plexTokenRedeemRequest, 'plexTokenRedeemRequest', 'sourcesPlexRedeemTokenCreate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const query: HttpQuery = {};

        if (slug != null) { query['slug'] = slug; }

        return this.request<RedirectChallenge>({
            url: '/sources/plex/redeem_token/',
            method: 'POST',
            headers,
            query,
            body: plexTokenRedeemRequest,
        }, opts?.responseOpts);
    };

    /**
     * Plex source Viewset
     */
    sourcesPlexRetrieve({ slug }: SourcesPlexRetrieveRequest): Observable<PlexSource>
    sourcesPlexRetrieve({ slug }: SourcesPlexRetrieveRequest, opts?: OperationOpts): Observable<AjaxResponse<PlexSource>>
    sourcesPlexRetrieve({ slug }: SourcesPlexRetrieveRequest, opts?: OperationOpts): Observable<PlexSource | AjaxResponse<PlexSource>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesPlexRetrieve');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<PlexSource>({
            url: '/sources/plex/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Plex source Viewset
     */
    sourcesPlexUpdate({ slug, plexSourceRequest }: SourcesPlexUpdateRequest): Observable<PlexSource>
    sourcesPlexUpdate({ slug, plexSourceRequest }: SourcesPlexUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<PlexSource>>
    sourcesPlexUpdate({ slug, plexSourceRequest }: SourcesPlexUpdateRequest, opts?: OperationOpts): Observable<PlexSource | AjaxResponse<PlexSource>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesPlexUpdate');
        throwIfNullOrUndefined(plexSourceRequest, 'plexSourceRequest', 'sourcesPlexUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<PlexSource>({
            url: '/sources/plex/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'PUT',
            headers,
            body: plexSourceRequest,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of all objects that use this object
     */
    sourcesPlexUsedByList({ slug }: SourcesPlexUsedByListRequest): Observable<Array<UsedBy>>
    sourcesPlexUsedByList({ slug }: SourcesPlexUsedByListRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<UsedBy>>>
    sourcesPlexUsedByList({ slug }: SourcesPlexUsedByListRequest, opts?: OperationOpts): Observable<Array<UsedBy> | AjaxResponse<Array<UsedBy>>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesPlexUsedByList');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Array<UsedBy>>({
            url: '/sources/plex/{slug}/used_by/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * SAMLSource Viewset
     */
    sourcesSamlCreate({ sAMLSourceRequest }: SourcesSamlCreateRequest): Observable<SAMLSource>
    sourcesSamlCreate({ sAMLSourceRequest }: SourcesSamlCreateRequest, opts?: OperationOpts): Observable<AjaxResponse<SAMLSource>>
    sourcesSamlCreate({ sAMLSourceRequest }: SourcesSamlCreateRequest, opts?: OperationOpts): Observable<SAMLSource | AjaxResponse<SAMLSource>> {
        throwIfNullOrUndefined(sAMLSourceRequest, 'sAMLSourceRequest', 'sourcesSamlCreate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<SAMLSource>({
            url: '/sources/saml/',
            method: 'POST',
            headers,
            body: sAMLSourceRequest,
        }, opts?.responseOpts);
    };

    /**
     * SAMLSource Viewset
     */
    sourcesSamlDestroy({ slug }: SourcesSamlDestroyRequest): Observable<void>
    sourcesSamlDestroy({ slug }: SourcesSamlDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    sourcesSamlDestroy({ slug }: SourcesSamlDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesSamlDestroy');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<void>({
            url: '/sources/saml/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * SAMLSource Viewset
     */
    sourcesSamlList({ allowIdpInitiated, authenticationFlow, bindingType, digestAlgorithm, enabled, enrollmentFlow, issuer, managed, name, nameIdPolicy, ordering, page, pageSize, policyEngineMode, preAuthenticationFlow, search, signatureAlgorithm, signingKp, sloUrl, slug, ssoUrl, temporaryUserDeleteAfter, userMatchingMode, verificationKp }: SourcesSamlListRequest): Observable<PaginatedSAMLSourceList>
    sourcesSamlList({ allowIdpInitiated, authenticationFlow, bindingType, digestAlgorithm, enabled, enrollmentFlow, issuer, managed, name, nameIdPolicy, ordering, page, pageSize, policyEngineMode, preAuthenticationFlow, search, signatureAlgorithm, signingKp, sloUrl, slug, ssoUrl, temporaryUserDeleteAfter, userMatchingMode, verificationKp }: SourcesSamlListRequest, opts?: OperationOpts): Observable<AjaxResponse<PaginatedSAMLSourceList>>
    sourcesSamlList({ allowIdpInitiated, authenticationFlow, bindingType, digestAlgorithm, enabled, enrollmentFlow, issuer, managed, name, nameIdPolicy, ordering, page, pageSize, policyEngineMode, preAuthenticationFlow, search, signatureAlgorithm, signingKp, sloUrl, slug, ssoUrl, temporaryUserDeleteAfter, userMatchingMode, verificationKp }: SourcesSamlListRequest, opts?: OperationOpts): Observable<PaginatedSAMLSourceList | AjaxResponse<PaginatedSAMLSourceList>> {

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const query: HttpQuery = {};

        if (allowIdpInitiated != null) { query['allow_idp_initiated'] = allowIdpInitiated; }
        if (authenticationFlow != null) { query['authentication_flow'] = authenticationFlow; }
        if (bindingType != null) { query['binding_type'] = bindingType; }
        if (digestAlgorithm != null) { query['digest_algorithm'] = digestAlgorithm; }
        if (enabled != null) { query['enabled'] = enabled; }
        if (enrollmentFlow != null) { query['enrollment_flow'] = enrollmentFlow; }
        if (issuer != null) { query['issuer'] = issuer; }
        if (managed != null) { query['managed'] = managed; }
        if (name != null) { query['name'] = name; }
        if (nameIdPolicy != null) { query['name_id_policy'] = nameIdPolicy; }
        if (ordering != null) { query['ordering'] = ordering; }
        if (page != null) { query['page'] = page; }
        if (pageSize != null) { query['page_size'] = pageSize; }
        if (policyEngineMode != null) { query['policy_engine_mode'] = policyEngineMode; }
        if (preAuthenticationFlow != null) { query['pre_authentication_flow'] = preAuthenticationFlow; }
        if (search != null) { query['search'] = search; }
        if (signatureAlgorithm != null) { query['signature_algorithm'] = signatureAlgorithm; }
        if (signingKp != null) { query['signing_kp'] = signingKp; }
        if (sloUrl != null) { query['slo_url'] = sloUrl; }
        if (slug != null) { query['slug'] = slug; }
        if (ssoUrl != null) { query['sso_url'] = ssoUrl; }
        if (temporaryUserDeleteAfter != null) { query['temporary_user_delete_after'] = temporaryUserDeleteAfter; }
        if (userMatchingMode != null) { query['user_matching_mode'] = userMatchingMode; }
        if (verificationKp != null) { query['verification_kp'] = verificationKp; }

        return this.request<PaginatedSAMLSourceList>({
            url: '/sources/saml/',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Return metadata as XML string
     */
    sourcesSamlMetadataRetrieve({ slug }: SourcesSamlMetadataRetrieveRequest): Observable<SAMLMetadata>
    sourcesSamlMetadataRetrieve({ slug }: SourcesSamlMetadataRetrieveRequest, opts?: OperationOpts): Observable<AjaxResponse<SAMLMetadata>>
    sourcesSamlMetadataRetrieve({ slug }: SourcesSamlMetadataRetrieveRequest, opts?: OperationOpts): Observable<SAMLMetadata | AjaxResponse<SAMLMetadata>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesSamlMetadataRetrieve');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<SAMLMetadata>({
            url: '/sources/saml/{slug}/metadata/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * SAMLSource Viewset
     */
    sourcesSamlPartialUpdate({ slug, patchedSAMLSourceRequest }: SourcesSamlPartialUpdateRequest): Observable<SAMLSource>
    sourcesSamlPartialUpdate({ slug, patchedSAMLSourceRequest }: SourcesSamlPartialUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<SAMLSource>>
    sourcesSamlPartialUpdate({ slug, patchedSAMLSourceRequest }: SourcesSamlPartialUpdateRequest, opts?: OperationOpts): Observable<SAMLSource | AjaxResponse<SAMLSource>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesSamlPartialUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<SAMLSource>({
            url: '/sources/saml/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'PATCH',
            headers,
            body: patchedSAMLSourceRequest,
        }, opts?.responseOpts);
    };

    /**
     * SAMLSource Viewset
     */
    sourcesSamlRetrieve({ slug }: SourcesSamlRetrieveRequest): Observable<SAMLSource>
    sourcesSamlRetrieve({ slug }: SourcesSamlRetrieveRequest, opts?: OperationOpts): Observable<AjaxResponse<SAMLSource>>
    sourcesSamlRetrieve({ slug }: SourcesSamlRetrieveRequest, opts?: OperationOpts): Observable<SAMLSource | AjaxResponse<SAMLSource>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesSamlRetrieve');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<SAMLSource>({
            url: '/sources/saml/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * SAMLSource Viewset
     */
    sourcesSamlUpdate({ slug, sAMLSourceRequest }: SourcesSamlUpdateRequest): Observable<SAMLSource>
    sourcesSamlUpdate({ slug, sAMLSourceRequest }: SourcesSamlUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<SAMLSource>>
    sourcesSamlUpdate({ slug, sAMLSourceRequest }: SourcesSamlUpdateRequest, opts?: OperationOpts): Observable<SAMLSource | AjaxResponse<SAMLSource>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesSamlUpdate');
        throwIfNullOrUndefined(sAMLSourceRequest, 'sAMLSourceRequest', 'sourcesSamlUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<SAMLSource>({
            url: '/sources/saml/{slug}/'.replace('{slug}', encodeURI(slug)),
            method: 'PUT',
            headers,
            body: sAMLSourceRequest,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of all objects that use this object
     */
    sourcesSamlUsedByList({ slug }: SourcesSamlUsedByListRequest): Observable<Array<UsedBy>>
    sourcesSamlUsedByList({ slug }: SourcesSamlUsedByListRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<UsedBy>>>
    sourcesSamlUsedByList({ slug }: SourcesSamlUsedByListRequest, opts?: OperationOpts): Observable<Array<UsedBy> | AjaxResponse<Array<UsedBy>>> {
        throwIfNullOrUndefined(slug, 'slug', 'sourcesSamlUsedByList');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Array<UsedBy>>({
            url: '/sources/saml/{slug}/used_by/'.replace('{slug}', encodeURI(slug)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * User-source connection Viewset
     */
    sourcesUserConnectionsAllDestroy({ id }: SourcesUserConnectionsAllDestroyRequest): Observable<void>
    sourcesUserConnectionsAllDestroy({ id }: SourcesUserConnectionsAllDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    sourcesUserConnectionsAllDestroy({ id }: SourcesUserConnectionsAllDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsAllDestroy');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<void>({
            url: '/sources/user_connections/all/{id}/'.replace('{id}', encodeURI(id)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * User-source connection Viewset
     */
    sourcesUserConnectionsAllList({ ordering, page, pageSize, search, user }: SourcesUserConnectionsAllListRequest): Observable<PaginatedUserSourceConnectionList>
    sourcesUserConnectionsAllList({ ordering, page, pageSize, search, user }: SourcesUserConnectionsAllListRequest, opts?: OperationOpts): Observable<AjaxResponse<PaginatedUserSourceConnectionList>>
    sourcesUserConnectionsAllList({ ordering, page, pageSize, search, user }: SourcesUserConnectionsAllListRequest, opts?: OperationOpts): Observable<PaginatedUserSourceConnectionList | AjaxResponse<PaginatedUserSourceConnectionList>> {

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const query: HttpQuery = {};

        if (ordering != null) { query['ordering'] = ordering; }
        if (page != null) { query['page'] = page; }
        if (pageSize != null) { query['page_size'] = pageSize; }
        if (search != null) { query['search'] = search; }
        if (user != null) { query['user'] = user; }

        return this.request<PaginatedUserSourceConnectionList>({
            url: '/sources/user_connections/all/',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * User-source connection Viewset
     */
    sourcesUserConnectionsAllPartialUpdate({ id }: SourcesUserConnectionsAllPartialUpdateRequest): Observable<UserSourceConnection>
    sourcesUserConnectionsAllPartialUpdate({ id }: SourcesUserConnectionsAllPartialUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<UserSourceConnection>>
    sourcesUserConnectionsAllPartialUpdate({ id }: SourcesUserConnectionsAllPartialUpdateRequest, opts?: OperationOpts): Observable<UserSourceConnection | AjaxResponse<UserSourceConnection>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsAllPartialUpdate');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<UserSourceConnection>({
            url: '/sources/user_connections/all/{id}/'.replace('{id}', encodeURI(id)),
            method: 'PATCH',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * User-source connection Viewset
     */
    sourcesUserConnectionsAllRetrieve({ id }: SourcesUserConnectionsAllRetrieveRequest): Observable<UserSourceConnection>
    sourcesUserConnectionsAllRetrieve({ id }: SourcesUserConnectionsAllRetrieveRequest, opts?: OperationOpts): Observable<AjaxResponse<UserSourceConnection>>
    sourcesUserConnectionsAllRetrieve({ id }: SourcesUserConnectionsAllRetrieveRequest, opts?: OperationOpts): Observable<UserSourceConnection | AjaxResponse<UserSourceConnection>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsAllRetrieve');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<UserSourceConnection>({
            url: '/sources/user_connections/all/{id}/'.replace('{id}', encodeURI(id)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * User-source connection Viewset
     */
    sourcesUserConnectionsAllUpdate({ id }: SourcesUserConnectionsAllUpdateRequest): Observable<UserSourceConnection>
    sourcesUserConnectionsAllUpdate({ id }: SourcesUserConnectionsAllUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<UserSourceConnection>>
    sourcesUserConnectionsAllUpdate({ id }: SourcesUserConnectionsAllUpdateRequest, opts?: OperationOpts): Observable<UserSourceConnection | AjaxResponse<UserSourceConnection>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsAllUpdate');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<UserSourceConnection>({
            url: '/sources/user_connections/all/{id}/'.replace('{id}', encodeURI(id)),
            method: 'PUT',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of all objects that use this object
     */
    sourcesUserConnectionsAllUsedByList({ id }: SourcesUserConnectionsAllUsedByListRequest): Observable<Array<UsedBy>>
    sourcesUserConnectionsAllUsedByList({ id }: SourcesUserConnectionsAllUsedByListRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<UsedBy>>>
    sourcesUserConnectionsAllUsedByList({ id }: SourcesUserConnectionsAllUsedByListRequest, opts?: OperationOpts): Observable<Array<UsedBy> | AjaxResponse<Array<UsedBy>>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsAllUsedByList');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Array<UsedBy>>({
            url: '/sources/user_connections/all/{id}/used_by/'.replace('{id}', encodeURI(id)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesUserConnectionsOauthCreate({ userOAuthSourceConnectionRequest }: SourcesUserConnectionsOauthCreateRequest): Observable<UserOAuthSourceConnection>
    sourcesUserConnectionsOauthCreate({ userOAuthSourceConnectionRequest }: SourcesUserConnectionsOauthCreateRequest, opts?: OperationOpts): Observable<AjaxResponse<UserOAuthSourceConnection>>
    sourcesUserConnectionsOauthCreate({ userOAuthSourceConnectionRequest }: SourcesUserConnectionsOauthCreateRequest, opts?: OperationOpts): Observable<UserOAuthSourceConnection | AjaxResponse<UserOAuthSourceConnection>> {
        throwIfNullOrUndefined(userOAuthSourceConnectionRequest, 'userOAuthSourceConnectionRequest', 'sourcesUserConnectionsOauthCreate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<UserOAuthSourceConnection>({
            url: '/sources/user_connections/oauth/',
            method: 'POST',
            headers,
            body: userOAuthSourceConnectionRequest,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesUserConnectionsOauthDestroy({ id }: SourcesUserConnectionsOauthDestroyRequest): Observable<void>
    sourcesUserConnectionsOauthDestroy({ id }: SourcesUserConnectionsOauthDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    sourcesUserConnectionsOauthDestroy({ id }: SourcesUserConnectionsOauthDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsOauthDestroy');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<void>({
            url: '/sources/user_connections/oauth/{id}/'.replace('{id}', encodeURI(id)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesUserConnectionsOauthList({ ordering, page, pageSize, search, sourceSlug }: SourcesUserConnectionsOauthListRequest): Observable<PaginatedUserOAuthSourceConnectionList>
    sourcesUserConnectionsOauthList({ ordering, page, pageSize, search, sourceSlug }: SourcesUserConnectionsOauthListRequest, opts?: OperationOpts): Observable<AjaxResponse<PaginatedUserOAuthSourceConnectionList>>
    sourcesUserConnectionsOauthList({ ordering, page, pageSize, search, sourceSlug }: SourcesUserConnectionsOauthListRequest, opts?: OperationOpts): Observable<PaginatedUserOAuthSourceConnectionList | AjaxResponse<PaginatedUserOAuthSourceConnectionList>> {

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const query: HttpQuery = {};

        if (ordering != null) { query['ordering'] = ordering; }
        if (page != null) { query['page'] = page; }
        if (pageSize != null) { query['page_size'] = pageSize; }
        if (search != null) { query['search'] = search; }
        if (sourceSlug != null) { query['source__slug'] = sourceSlug; }

        return this.request<PaginatedUserOAuthSourceConnectionList>({
            url: '/sources/user_connections/oauth/',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesUserConnectionsOauthPartialUpdate({ id, patchedUserOAuthSourceConnectionRequest }: SourcesUserConnectionsOauthPartialUpdateRequest): Observable<UserOAuthSourceConnection>
    sourcesUserConnectionsOauthPartialUpdate({ id, patchedUserOAuthSourceConnectionRequest }: SourcesUserConnectionsOauthPartialUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<UserOAuthSourceConnection>>
    sourcesUserConnectionsOauthPartialUpdate({ id, patchedUserOAuthSourceConnectionRequest }: SourcesUserConnectionsOauthPartialUpdateRequest, opts?: OperationOpts): Observable<UserOAuthSourceConnection | AjaxResponse<UserOAuthSourceConnection>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsOauthPartialUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<UserOAuthSourceConnection>({
            url: '/sources/user_connections/oauth/{id}/'.replace('{id}', encodeURI(id)),
            method: 'PATCH',
            headers,
            body: patchedUserOAuthSourceConnectionRequest,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesUserConnectionsOauthRetrieve({ id }: SourcesUserConnectionsOauthRetrieveRequest): Observable<UserOAuthSourceConnection>
    sourcesUserConnectionsOauthRetrieve({ id }: SourcesUserConnectionsOauthRetrieveRequest, opts?: OperationOpts): Observable<AjaxResponse<UserOAuthSourceConnection>>
    sourcesUserConnectionsOauthRetrieve({ id }: SourcesUserConnectionsOauthRetrieveRequest, opts?: OperationOpts): Observable<UserOAuthSourceConnection | AjaxResponse<UserOAuthSourceConnection>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsOauthRetrieve');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<UserOAuthSourceConnection>({
            url: '/sources/user_connections/oauth/{id}/'.replace('{id}', encodeURI(id)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesUserConnectionsOauthUpdate({ id, userOAuthSourceConnectionRequest }: SourcesUserConnectionsOauthUpdateRequest): Observable<UserOAuthSourceConnection>
    sourcesUserConnectionsOauthUpdate({ id, userOAuthSourceConnectionRequest }: SourcesUserConnectionsOauthUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<UserOAuthSourceConnection>>
    sourcesUserConnectionsOauthUpdate({ id, userOAuthSourceConnectionRequest }: SourcesUserConnectionsOauthUpdateRequest, opts?: OperationOpts): Observable<UserOAuthSourceConnection | AjaxResponse<UserOAuthSourceConnection>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsOauthUpdate');
        throwIfNullOrUndefined(userOAuthSourceConnectionRequest, 'userOAuthSourceConnectionRequest', 'sourcesUserConnectionsOauthUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<UserOAuthSourceConnection>({
            url: '/sources/user_connections/oauth/{id}/'.replace('{id}', encodeURI(id)),
            method: 'PUT',
            headers,
            body: userOAuthSourceConnectionRequest,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of all objects that use this object
     */
    sourcesUserConnectionsOauthUsedByList({ id }: SourcesUserConnectionsOauthUsedByListRequest): Observable<Array<UsedBy>>
    sourcesUserConnectionsOauthUsedByList({ id }: SourcesUserConnectionsOauthUsedByListRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<UsedBy>>>
    sourcesUserConnectionsOauthUsedByList({ id }: SourcesUserConnectionsOauthUsedByListRequest, opts?: OperationOpts): Observable<Array<UsedBy> | AjaxResponse<Array<UsedBy>>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsOauthUsedByList');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Array<UsedBy>>({
            url: '/sources/user_connections/oauth/{id}/used_by/'.replace('{id}', encodeURI(id)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Plex Source connection Serializer
     */
    sourcesUserConnectionsPlexCreate({ plexSourceConnectionRequest }: SourcesUserConnectionsPlexCreateRequest): Observable<PlexSourceConnection>
    sourcesUserConnectionsPlexCreate({ plexSourceConnectionRequest }: SourcesUserConnectionsPlexCreateRequest, opts?: OperationOpts): Observable<AjaxResponse<PlexSourceConnection>>
    sourcesUserConnectionsPlexCreate({ plexSourceConnectionRequest }: SourcesUserConnectionsPlexCreateRequest, opts?: OperationOpts): Observable<PlexSourceConnection | AjaxResponse<PlexSourceConnection>> {
        throwIfNullOrUndefined(plexSourceConnectionRequest, 'plexSourceConnectionRequest', 'sourcesUserConnectionsPlexCreate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<PlexSourceConnection>({
            url: '/sources/user_connections/plex/',
            method: 'POST',
            headers,
            body: plexSourceConnectionRequest,
        }, opts?.responseOpts);
    };

    /**
     * Plex Source connection Serializer
     */
    sourcesUserConnectionsPlexDestroy({ id }: SourcesUserConnectionsPlexDestroyRequest): Observable<void>
    sourcesUserConnectionsPlexDestroy({ id }: SourcesUserConnectionsPlexDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    sourcesUserConnectionsPlexDestroy({ id }: SourcesUserConnectionsPlexDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsPlexDestroy');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<void>({
            url: '/sources/user_connections/plex/{id}/'.replace('{id}', encodeURI(id)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Plex Source connection Serializer
     */
    sourcesUserConnectionsPlexList({ ordering, page, pageSize, search, sourceSlug }: SourcesUserConnectionsPlexListRequest): Observable<PaginatedPlexSourceConnectionList>
    sourcesUserConnectionsPlexList({ ordering, page, pageSize, search, sourceSlug }: SourcesUserConnectionsPlexListRequest, opts?: OperationOpts): Observable<AjaxResponse<PaginatedPlexSourceConnectionList>>
    sourcesUserConnectionsPlexList({ ordering, page, pageSize, search, sourceSlug }: SourcesUserConnectionsPlexListRequest, opts?: OperationOpts): Observable<PaginatedPlexSourceConnectionList | AjaxResponse<PaginatedPlexSourceConnectionList>> {

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const query: HttpQuery = {};

        if (ordering != null) { query['ordering'] = ordering; }
        if (page != null) { query['page'] = page; }
        if (pageSize != null) { query['page_size'] = pageSize; }
        if (search != null) { query['search'] = search; }
        if (sourceSlug != null) { query['source__slug'] = sourceSlug; }

        return this.request<PaginatedPlexSourceConnectionList>({
            url: '/sources/user_connections/plex/',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Plex Source connection Serializer
     */
    sourcesUserConnectionsPlexPartialUpdate({ id, patchedPlexSourceConnectionRequest }: SourcesUserConnectionsPlexPartialUpdateRequest): Observable<PlexSourceConnection>
    sourcesUserConnectionsPlexPartialUpdate({ id, patchedPlexSourceConnectionRequest }: SourcesUserConnectionsPlexPartialUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<PlexSourceConnection>>
    sourcesUserConnectionsPlexPartialUpdate({ id, patchedPlexSourceConnectionRequest }: SourcesUserConnectionsPlexPartialUpdateRequest, opts?: OperationOpts): Observable<PlexSourceConnection | AjaxResponse<PlexSourceConnection>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsPlexPartialUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<PlexSourceConnection>({
            url: '/sources/user_connections/plex/{id}/'.replace('{id}', encodeURI(id)),
            method: 'PATCH',
            headers,
            body: patchedPlexSourceConnectionRequest,
        }, opts?.responseOpts);
    };

    /**
     * Plex Source connection Serializer
     */
    sourcesUserConnectionsPlexRetrieve({ id }: SourcesUserConnectionsPlexRetrieveRequest): Observable<PlexSourceConnection>
    sourcesUserConnectionsPlexRetrieve({ id }: SourcesUserConnectionsPlexRetrieveRequest, opts?: OperationOpts): Observable<AjaxResponse<PlexSourceConnection>>
    sourcesUserConnectionsPlexRetrieve({ id }: SourcesUserConnectionsPlexRetrieveRequest, opts?: OperationOpts): Observable<PlexSourceConnection | AjaxResponse<PlexSourceConnection>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsPlexRetrieve');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<PlexSourceConnection>({
            url: '/sources/user_connections/plex/{id}/'.replace('{id}', encodeURI(id)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Plex Source connection Serializer
     */
    sourcesUserConnectionsPlexUpdate({ id, plexSourceConnectionRequest }: SourcesUserConnectionsPlexUpdateRequest): Observable<PlexSourceConnection>
    sourcesUserConnectionsPlexUpdate({ id, plexSourceConnectionRequest }: SourcesUserConnectionsPlexUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<PlexSourceConnection>>
    sourcesUserConnectionsPlexUpdate({ id, plexSourceConnectionRequest }: SourcesUserConnectionsPlexUpdateRequest, opts?: OperationOpts): Observable<PlexSourceConnection | AjaxResponse<PlexSourceConnection>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsPlexUpdate');
        throwIfNullOrUndefined(plexSourceConnectionRequest, 'plexSourceConnectionRequest', 'sourcesUserConnectionsPlexUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<PlexSourceConnection>({
            url: '/sources/user_connections/plex/{id}/'.replace('{id}', encodeURI(id)),
            method: 'PUT',
            headers,
            body: plexSourceConnectionRequest,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of all objects that use this object
     */
    sourcesUserConnectionsPlexUsedByList({ id }: SourcesUserConnectionsPlexUsedByListRequest): Observable<Array<UsedBy>>
    sourcesUserConnectionsPlexUsedByList({ id }: SourcesUserConnectionsPlexUsedByListRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<UsedBy>>>
    sourcesUserConnectionsPlexUsedByList({ id }: SourcesUserConnectionsPlexUsedByListRequest, opts?: OperationOpts): Observable<Array<UsedBy> | AjaxResponse<Array<UsedBy>>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsPlexUsedByList');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Array<UsedBy>>({
            url: '/sources/user_connections/plex/{id}/used_by/'.replace('{id}', encodeURI(id)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesUserConnectionsSamlCreate({ userSAMLSourceConnectionRequest }: SourcesUserConnectionsSamlCreateRequest): Observable<UserSAMLSourceConnection>
    sourcesUserConnectionsSamlCreate({ userSAMLSourceConnectionRequest }: SourcesUserConnectionsSamlCreateRequest, opts?: OperationOpts): Observable<AjaxResponse<UserSAMLSourceConnection>>
    sourcesUserConnectionsSamlCreate({ userSAMLSourceConnectionRequest }: SourcesUserConnectionsSamlCreateRequest, opts?: OperationOpts): Observable<UserSAMLSourceConnection | AjaxResponse<UserSAMLSourceConnection>> {
        throwIfNullOrUndefined(userSAMLSourceConnectionRequest, 'userSAMLSourceConnectionRequest', 'sourcesUserConnectionsSamlCreate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<UserSAMLSourceConnection>({
            url: '/sources/user_connections/saml/',
            method: 'POST',
            headers,
            body: userSAMLSourceConnectionRequest,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesUserConnectionsSamlDestroy({ id }: SourcesUserConnectionsSamlDestroyRequest): Observable<void>
    sourcesUserConnectionsSamlDestroy({ id }: SourcesUserConnectionsSamlDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    sourcesUserConnectionsSamlDestroy({ id }: SourcesUserConnectionsSamlDestroyRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsSamlDestroy');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<void>({
            url: '/sources/user_connections/saml/{id}/'.replace('{id}', encodeURI(id)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesUserConnectionsSamlList({ ordering, page, pageSize, search, sourceSlug }: SourcesUserConnectionsSamlListRequest): Observable<PaginatedUserSAMLSourceConnectionList>
    sourcesUserConnectionsSamlList({ ordering, page, pageSize, search, sourceSlug }: SourcesUserConnectionsSamlListRequest, opts?: OperationOpts): Observable<AjaxResponse<PaginatedUserSAMLSourceConnectionList>>
    sourcesUserConnectionsSamlList({ ordering, page, pageSize, search, sourceSlug }: SourcesUserConnectionsSamlListRequest, opts?: OperationOpts): Observable<PaginatedUserSAMLSourceConnectionList | AjaxResponse<PaginatedUserSAMLSourceConnectionList>> {

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        const query: HttpQuery = {};

        if (ordering != null) { query['ordering'] = ordering; }
        if (page != null) { query['page'] = page; }
        if (pageSize != null) { query['page_size'] = pageSize; }
        if (search != null) { query['search'] = search; }
        if (sourceSlug != null) { query['source__slug'] = sourceSlug; }

        return this.request<PaginatedUserSAMLSourceConnectionList>({
            url: '/sources/user_connections/saml/',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesUserConnectionsSamlPartialUpdate({ id, patchedUserSAMLSourceConnectionRequest }: SourcesUserConnectionsSamlPartialUpdateRequest): Observable<UserSAMLSourceConnection>
    sourcesUserConnectionsSamlPartialUpdate({ id, patchedUserSAMLSourceConnectionRequest }: SourcesUserConnectionsSamlPartialUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<UserSAMLSourceConnection>>
    sourcesUserConnectionsSamlPartialUpdate({ id, patchedUserSAMLSourceConnectionRequest }: SourcesUserConnectionsSamlPartialUpdateRequest, opts?: OperationOpts): Observable<UserSAMLSourceConnection | AjaxResponse<UserSAMLSourceConnection>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsSamlPartialUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<UserSAMLSourceConnection>({
            url: '/sources/user_connections/saml/{id}/'.replace('{id}', encodeURI(id)),
            method: 'PATCH',
            headers,
            body: patchedUserSAMLSourceConnectionRequest,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesUserConnectionsSamlRetrieve({ id }: SourcesUserConnectionsSamlRetrieveRequest): Observable<UserSAMLSourceConnection>
    sourcesUserConnectionsSamlRetrieve({ id }: SourcesUserConnectionsSamlRetrieveRequest, opts?: OperationOpts): Observable<AjaxResponse<UserSAMLSourceConnection>>
    sourcesUserConnectionsSamlRetrieve({ id }: SourcesUserConnectionsSamlRetrieveRequest, opts?: OperationOpts): Observable<UserSAMLSourceConnection | AjaxResponse<UserSAMLSourceConnection>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsSamlRetrieve');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<UserSAMLSourceConnection>({
            url: '/sources/user_connections/saml/{id}/'.replace('{id}', encodeURI(id)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Source Viewset
     */
    sourcesUserConnectionsSamlUpdate({ id, userSAMLSourceConnectionRequest }: SourcesUserConnectionsSamlUpdateRequest): Observable<UserSAMLSourceConnection>
    sourcesUserConnectionsSamlUpdate({ id, userSAMLSourceConnectionRequest }: SourcesUserConnectionsSamlUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<UserSAMLSourceConnection>>
    sourcesUserConnectionsSamlUpdate({ id, userSAMLSourceConnectionRequest }: SourcesUserConnectionsSamlUpdateRequest, opts?: OperationOpts): Observable<UserSAMLSourceConnection | AjaxResponse<UserSAMLSourceConnection>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsSamlUpdate');
        throwIfNullOrUndefined(userSAMLSourceConnectionRequest, 'userSAMLSourceConnectionRequest', 'sourcesUserConnectionsSamlUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<UserSAMLSourceConnection>({
            url: '/sources/user_connections/saml/{id}/'.replace('{id}', encodeURI(id)),
            method: 'PUT',
            headers,
            body: userSAMLSourceConnectionRequest,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of all objects that use this object
     */
    sourcesUserConnectionsSamlUsedByList({ id }: SourcesUserConnectionsSamlUsedByListRequest): Observable<Array<UsedBy>>
    sourcesUserConnectionsSamlUsedByList({ id }: SourcesUserConnectionsSamlUsedByListRequest, opts?: OperationOpts): Observable<AjaxResponse<Array<UsedBy>>>
    sourcesUserConnectionsSamlUsedByList({ id }: SourcesUserConnectionsSamlUsedByListRequest, opts?: OperationOpts): Observable<Array<UsedBy> | AjaxResponse<Array<UsedBy>>> {
        throwIfNullOrUndefined(id, 'id', 'sourcesUserConnectionsSamlUsedByList');

        const headers: HttpHeaders = {
            ...(this.configuration.apiKey && { 'Authorization': this.configuration.apiKey('Authorization') }), // authentik authentication
        };

        return this.request<Array<UsedBy>>({
            url: '/sources/user_connections/saml/{id}/used_by/'.replace('{id}', encodeURI(id)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

}

/**
 * @export
 * @enum {string}
 */
export enum SourcesOauthListPolicyEngineModeEnum {
    All = 'all',
    Any = 'any'
}
/**
 * @export
 * @enum {string}
 */
export enum SourcesOauthListUserMatchingModeEnum {
    EmailDeny = 'email_deny',
    EmailLink = 'email_link',
    Identifier = 'identifier',
    UsernameDeny = 'username_deny',
    UsernameLink = 'username_link'
}
/**
 * @export
 * @enum {string}
 */
export enum SourcesPlexListPolicyEngineModeEnum {
    All = 'all',
    Any = 'any'
}
/**
 * @export
 * @enum {string}
 */
export enum SourcesPlexListUserMatchingModeEnum {
    EmailDeny = 'email_deny',
    EmailLink = 'email_link',
    Identifier = 'identifier',
    UsernameDeny = 'username_deny',
    UsernameLink = 'username_link'
}
/**
 * @export
 * @enum {string}
 */
export enum SourcesSamlListBindingTypeEnum {
    Post = 'POST',
    PostAuto = 'POST_AUTO',
    Redirect = 'REDIRECT'
}
/**
 * @export
 * @enum {string}
 */
export enum SourcesSamlListDigestAlgorithmEnum {
    _200009Xmldsigsha1 = 'http://www.w3.org/2000/09/xmldsig#sha1',
    _200104XmldsigMoresha384 = 'http://www.w3.org/2001/04/xmldsig-more#sha384',
    _200104Xmlencsha256 = 'http://www.w3.org/2001/04/xmlenc#sha256',
    _200104Xmlencsha512 = 'http://www.w3.org/2001/04/xmlenc#sha512'
}
/**
 * @export
 * @enum {string}
 */
export enum SourcesSamlListNameIdPolicyEnum {
    _11nameidFormatemailAddress = 'urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress',
    _20nameidFormatWindowsDomainQualifiedName = 'urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName',
    _20nameidFormatX509SubjectName = 'urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName',
    _20nameidFormatpersistent = 'urn:oasis:names:tc:SAML:2.0:nameid-format:persistent',
    _20nameidFormattransient = 'urn:oasis:names:tc:SAML:2.0:nameid-format:transient'
}
/**
 * @export
 * @enum {string}
 */
export enum SourcesSamlListPolicyEngineModeEnum {
    All = 'all',
    Any = 'any'
}
/**
 * @export
 * @enum {string}
 */
export enum SourcesSamlListSignatureAlgorithmEnum {
    _200009XmldsigdsaSha1 = 'http://www.w3.org/2000/09/xmldsig#dsa-sha1',
    _200009XmldsigrsaSha1 = 'http://www.w3.org/2000/09/xmldsig#rsa-sha1',
    _200104XmldsigMorersaSha256 = 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256',
    _200104XmldsigMorersaSha384 = 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha384',
    _200104XmldsigMorersaSha512 = 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha512'
}
/**
 * @export
 * @enum {string}
 */
export enum SourcesSamlListUserMatchingModeEnum {
    EmailDeny = 'email_deny',
    EmailLink = 'email_link',
    Identifier = 'identifier',
    UsernameDeny = 'username_deny',
    UsernameLink = 'username_link'
}
